<h2>History and ownership of three JavaScript frameworks</h2>
<p>
Every project starts because there's a problem that needs to be solved. JavaScript frameworks are no different. Angular, React, and View were all created to solve a specific type of problem. Knowing the reason each framework was created, may help you choose the best framework for your needs. The same holds true for ownership. Knowing who owns each framework will help you make an informed choice. Angular started life at Google as a side project to help employees build internal web apps. Google released version one of angular to the public back in 2010 and the community loved it. I've worked with angular since version 1.3 and I've seen first hand how it's matured into a stable platform with full support for everything you need to build a web application. Google's angular team maintains the framework with the help of a large community of open source contributors. Google still owns the copyright as of this recording. React started at Facebook, now called meta platforms, as a way to manage the growing complexity of their advertising code base. Facebook bought Instagram in 2012. After the acquisition, the Instagram team wanted to use Facebook's UI library for the Instagram website. After enough pressure, Facebook released the library in 2013 under the name React. Facebook still owns the copyright. The main focus of React is state management and dom rendering. This means you'll need to use other tools alongside React for things like app routing and HTTP (indistinct) requests. Much like Angular, Facebook's React team maintains the library with the help of a large community of open source contributors. Angular and React are great choices if you like the idea of a big tech company leading the future development of your JavaScript framework. Of the three frameworks we'll talk about in this course, View JS is the only one not owned by a big tech company. A guy named Evan You, spelled Y O U, invented the View framework while working at Google's creative lab. Google asked Evan to come up with a way to do fancy 3D animations in Google Chrome. Evan didn't like any of the JavaScript frameworks available at the time so he made his own. Evan released View to the public in 2014 and he still owns the copyright. View is a progressive framework. This means you can use it inside an existing project without touching other parts of the app. Evan maintains the framework with the help of a core team of developers and a large community of open source contributors. View JS is a great choice if you like the idea of an independent team leading the way forward on your framework. Check out the exercise files for links to more info.
</p>

<p>
<h2>Release and support cycles for Angular, React, and Vue</h2>
<br />
No matter how big your project is, the underlying JavaScript framework must be stable and secure. The more stable the framework, the more you and your team can plan long-term releases for your project. This is why it's vital to know the release and support cycles for any JavaScript framework you might use. Angular, React, and Vue all use semantic versioning to track changes and releases. Semantic versioning, SemVer for short, is both a strategy and a naming convention. It helps you and everyone else know exactly what to expect from each new release, in turn, this makes it easier for you and your team to plan upgrades in your project. There are always three types of releases when using SemVer, major releases, minor releases, and patch releases. And while there are official definitions for each type of release, Angular, React, and Vue each have their own flavor. In Angular, major releases contain big, new features. This type of release is sometimes called a breaking change because you may need to learn a new API, refactor your code, or upgrade config files. Angular publishes a new major release every six months and they usually include an upgrade path for previous versions. Minor releases contain smaller, new features that are backwards compatible with previous versions. There's usually no need to refactor code when upgrading to a new minor release. Patch releases are usually low-risk fixes for bugs and security. It's a good idea to upgrade to the latest patch release as soon as you can. Angular publishes one to three minor releases for each major release, but there's no fixed release dates. Angular publishes a new patch release about once per week. The Angular team supports each major release for 18 months. The first six months are considered active support with both minor and patch releases, and the next 12 months are considered long-term support with only patch releases. React's release strategy is very similar to Angular's. Major releases include breaking changes, new features, and bug fixes. Minor releases include backwards compatible features and non-critical bug fixes. The React team reserves patch releases for critical bug fixes. This makes it easier for you and your team to tell if there's a critical release that needs your immediate attention. There's no fixed schedule for releases but the React team will add warnings about breaking changes before they publish the new release. There's also no official support policy for React as of this recording. As a general rule, the React team will publish minor releases only for the most current major release. They will, however, publish patch releases for all previous versions as needed. As of this recording, Vue doesn't schedule releases the same way Angular and React do. This means there's no way of knowing for sure when the next release will happen. Depending on your project, this may mean the difference between using Vue or using a different framework. It's a choice you and your team will need to make. When Vue releases a new major version, the last version becomes a long-term support release. So for example, when Vue released version 3.0, version 2.6 became their long-term support version, or LTS for short. Vue supports LTS versions with bug fixes and security patches for the first 18 months, and then with security patches only for the next 18 months. This gives you a total of 36 months of long-term support. Remember to check out the exercise files for links to more info.
</p>

<p>
<h2>The MIT license and why it matters</h2>
<br />A software license is a legal document that governs where and how you can use a piece of code owned by someone else. Some licenses have a lot of restrictions and require payment to use the software. Other licenses are more permissive and some developers release their software into the public domain, which has no restrictions at all. The type of license that comes with your JavaScript framework matters. This is especially true if you're building an application that includes proprietary code or that end users will pay for. Some licenses won't let you do that. Lucky for us, as of this recording Angular, React and View are all released under a very permissive license called the MIT license. This license started back in the late 1980s at the Massachusetts Institute of Technology. Hence the name, MIT. Some places call it the ex-pat license or the X-11 license. But the terms of use are mostly the same. It's one of the most permissive licenses out there for open source projects. And it's also one of the shortest at only about 165 words. The license gives you and your team the freedom to use the software free of charge for whatever you want. As long as you include the copyright notice and license info. The MIT license is also compatible with the GNU General Public license as well as Debian's free software guidelines. And it's approved by the free software foundation and the Open Source Initiative. Depending on other software you use in your project you may need this extra compatibility and approval. The only downside to such a permissive license might be its lack of warranty. Software released under the MIT license is provided as is and the copyright holders cannot be held liable if something goes wrong when you use the software. This might sound scary, but many developers including me, feel the benefits of using software available under an MIT license outweigh its lack of warranty. While every project is unique, I've never had an issue using MIT license software in my work. Your needs might be different and you may need to use software that comes with a warranty. I recommend you speak with your legal team to confirm if the MIT license will work for your specific needs. Check out the exercise files for links to more info.
</p>

<p><h2>Development workflow inside Angular, React, and Vue</h2>
<br />
Modern JavaScript frameworks usually come with their own ecosystem of developer tools and workflows. The frameworks creators built these ecosystems to make you more productive as a developer. You may find that some of these ecosystems are a better fit, based on the tools and workflows you and your team already use. Angular CLI is the official command line tool for Angular projects. It's open source and released under the MIT license. The Angular team releases a new major version of the CLI tool when they release a new major version of the framework itself. They release minor and patch versions as needed independent of the framework. The major version of the CLI tool usually has the same number as the framework it works with. So version 14 of the CLI tool works with version 14 of the framework and so on. This makes it easy to upgrade all your projects dependencies at once when needed. Angular CLI tool is robust and will be a big part of your everyday workflow. You'll use it to initialize and configure your new project, run builds, generate new files and Lin and test your code. If you like the idea of an all-in-one CLI tool, Angular might be a good fit for your next project. Reacts CLI tool is called Create React App and it does just that. It helps you initialize and configure a new React project. The tool is open source and released under the MIT license. You won't use the CLI tool once your new project is up and running. You'll use NPM commands for day-to-day tasks like starting a local dev server and generating production builds. You and your team might like React if you're okay with manually adding new files and already make heavy use of NPM commands. One last note about React's CLI tool, while the React team officially supports Create React App, there are other third party CLI tools out there that may work better for your needs. Just search for React CLI using your favorite search engine to see all your options. Vue CLI is the official command line tool for VueJS projects. This tool is also open source and released under the MIT license. It comes in two parts, the CLI tool itself, which you use to initialize and configure new projects and the CLI service which you use to manage plugins and generate builds. These tools are a big part of the development workflow for Vue projects and the VueJS team releases new versions of the CLI tool as needed. If you want a CLI tool that's more modular and customizable, you and your team might like VueJS. Be sure to check out the exercise files for links to more info.
</p>

<p>
<h2>What you can build out-of-the-box</h2><br />

Angular, React and Vue were all built to solve slightly different problems when it comes to web apps. This means a fresh install of each framework comes with its own benefits and limitations. Depending on your goals, you and your team may find one framework a better fit for your needs right out of the box. Angular was originally designed to build single page applications or SPAs. SPAs at their core are just websites where the content updates dynamically without the need to refresh the browser. This makes the website feel more like a native app experience. Today, Angular is still great for single page applications, but the ecosystem's evolved. Now there's reusable components, standard libraries, and routing. The official website positions Angular as a platform, not just a framework. And I think this description is accurate. In short, you can build any type of application at scale, right out of the box. React is all about building complex user interfaces using small isolated pieces of code called components. Today, it's very common to use a component based architecture when building an application. But when React first came out, component based apps were still an amazing new idea. React revolutionized how the entire industry thinks about building apps. Out of the box, you can use React to build a one page application or small isolated features. You'll need to add dependencies for routing and state management, as things get more complex. Vue is built from the ground up to be a modular framework. Use the dependencies you need, leave out what you don't. This means you can build any type of component based app you want, as long as you install the correct dependencies. The official command line tool for Vue makes this very easy for you. Just follow the prompts to install the dependencies you need. Check out the exercise files for links to more info.
</p>

<p></h2> 
Configuring your JavaScript framework</h2>
How a JavaScript framework organizes source code and config files can make a huge difference in your experience using the framework. Depending on your needs, you may find one strategy works better for you than another. Angular manages dependencies using npm. This means you'll need to install Node.js on all the systems that touch the source code. This includes developer workstations and any servers where you build your code. React and Vue also use npm to manage project dependencies. This means you'll get access to the entire ecosystem of npm plugins and libraries, no matter which framework you choose. In all Angular projects, the two big configuration files are tsconfig.json and angular.json. You write Angular app using TypeScript and the tsconfig file tells the TypeScript compiler how to generate JavaScript code. The Angular CLI tool configures sensible TypeScript defaults when you start a new project, but you can always change the settings if needed. Angular.json is where you tell Angular CLI how to configure your project. This is where you specify things like environment variables and file path aliases for all your build targets. Again, this file is full of sensible defaults when you start a new project using the CLI tool. You store all your app code in the source folder in the root of your project. It's convention in Angular projects to organize your code by component and the Angular CLI tool does this for you automatically when you generate new files. This means the HTML template, the module loader and any other code related to the component sits together in the same folder. I'm a big fan of organizing source code by component. It makes editing code much easier because I don't need to hunt down related files. Everything I need is in one place. A lot of React projects organize their source code by component but you don't have to. You can organize your code however you like, as long as you configure React correctly. You write React apps using a syntax called JSX, which is a cross between JavaScript and HTML. JSX is not a replacement for JavaScript, which means you need a compiler to generate JavaScript code. React uses Webpack, an open source aesthetic module bundler to compile JSX files into vanilla JavaScript that web browsers can actually understand. Remember to update your Webpack config if you change how you organize the files in your React project. The JSX syntax is sometimes called JavaScript Extension or JavaScript React. Whichever name you use, it's the preferred syntax for React projects, which leads us to one of the biggest differences between Angular and React. The JSX syntax expects you to put your HTML template in the same file as your JavaScript code. This is why there are no HTML files in a React project. The JavaScript file is the HTML template. Let that sink in for a sec because what we're talking about here is a fundamental difference between the two frameworks. Angular's syntax embeds custom attributes inside HTML to manage things like if-then statements, array loops and dynamic content. Templates are always separate from the logic that controls them. React's syntax uses standard JavaScript to do the same things and templates are always embedded within their controllers. Take a look at both frameworks. You may find one strategy works better for you than the other. The Vue framework takes things one step further with something they call single file components, or SFCs. Single file components put HMTL, JavaScript and CSS in one file. Vue uses its own custom compiler to break out the JavaScript, HTML and CSS at build time and with SFCs, you get the extra benefits of scoped CSS and compile time optimizations. You also get hot module replacement, which lets you change templates without rerendering the page or resetting the state. One more thing to note about Vue projects. Vue supports two different API styles for writing components. They call these the Options API and the Composition API. With the Options API, you define your component's logic using a configuration object. You access data and methods on the component instance using the this keyword. The Composition API lets you define your component's logic using imported helper functions and standard function definitions. You can use either style for most use cases. The Options API is great if you come from a class-based or object-oriented background and the Composition API may suit you better if you prefer a more functional approach to writing code. Try both styles and see which might work best for you. Check out the exercise files for links to more info.
</p>

<p>
<h2>Bootstrapping content in Angular, React, and Vue</h2>
<br />Angular, React and Vue all bootstrap content in slightly different ways. They also give you slightly different hooks into the lifecycle of your components. Angular applications are built around the concept of modules. Modules might include components, services or other utilities. And they tell Angular how the parts of your application fit together. Every Angular app has at least one root module. This is where you tell Angular which components to load when your application launches. While you could load more than one component on app launch, this is rare. I've never seen it done in my work. Most projects load only one root module and only one main component. Angular uses the component selector to find the mount point in the DOM. The selector can be any custom HTML element but it's usually app-root in most of the projects I've seen. On load, Angular will populate the selector with the content of the component's template. The selector itself is not considered part of the template and stays in the DOM. The life of an Angular component starts when the framework instantiates the component's class, and renders the template in the DOM. The component is now alive and ready to react to changes. The lifecycle ends when Angular destroys the component instance and removes its content from the DOM. Angular exposes eight lifecycle hooks for each component. These hooks let you run your own code when Angular first initializes the component, when the template loads in the DOM, when changes happen and when Angular destroys the component. Lifecycle hooks are a big part of building an Angular app and I use them all the time, especially when working with observables. You always want to unsubscribe from an observable when Angular destroys the component. React apps are similar to Angular. They need a root component, and a mounting point in the DOM. The root component can be as big or as small as you need it to be. Many React projects have one app component at its root with all other components as children but it doesn't need to be this way. You could start small and add React to an existing project only where you need it. The lifecycle of a React component starts when React mounts an instance of the component and renders the template in the DOM. The component then listens for updates and change of state is needed to stay in sync. The lifecycle ends when React unmounts the component and removes it from the DOM. React exposes eight lifecycle hooks for each component. These hooks give you access to the component's constructor, its full render cycle, as well as when the component mounts in the DOM, changes and unmounts from the DOM. The most common hooks are after a component mounts, after it changes and before it unmounts. Vue applications are like React apps. They need an app instance, and a root component. There's only one root component for each instance of a Vue app but you can have multiple Vue instances on the same webpage, each with its own isolated scope. Vue apps can be as big or small as you want them to be. Add a Vue app only where you need it and Vue will ignore the rest of the page. This makes it easy to add Vue to an existing project. Use standard DOM selectors to tell Vue where to mount your app instance and pass in a reference to your root component. Vue will render your root component inside the mount point. Mount points are not considered part of the app. They're just containers. Each app instance has its own top-level configuration object. This is where you set things like app level error handlers or assets you want available anywhere in the app. Remember to configure your app instance before mounting it. Vue exposes a total of 12 lifecycle hooks on each component you can use to run your own code. These hooks give you access to the component before and after it mounts, before and after it updates, the component's render cycle, and when the component suspends and resumes. If you need a JavaScript framework that works well inside existing projects, or that lets you mount many apps on the same page, Vue and React might be good choices for your needs. Angular might be a good choice if you need tight coupling between all the components, services and other utilities in your project. Check out the exercise files for links to more info.</p>

<p><h2>
 Change detection and app state inside JavaScript frameworks</h2>
<br />
Change detection is how a JavaScript framework watches for changes in the application state, and how it applies those changes to the rest of the app. How a framework does this can impact performance as well as how easy it is for you to debug the code. Angulars change detection works by patching low-level browser APIs like add event listener with custom code. This code triggers Angulars comparison function as a side effect when calling the original API. So for example, when a user taps a button in your app, this triggers the click event, which executes your callback as well as Angular's custom code. Angular patches all browser events like click and key up as well as set timeout, set interval and all HTTP requests. Angular uses a dependency called Zone JS to patch other APIs like web sockets and local storage. This all happens behind the scenes, and you should never need to modify how Angular patches the APIs. Every component in Angular registers a change detector with the framework at run time. Angular uses this collection of change detectors called a change detection tree to track application state in memory. When a component triggers a change detector, angular compares the new state with the old state using a strict equality comparison. It marks the things that changed with a Boolean and Angular reruns only the code that needs the changes. Changes always happen in one direction, parent to child to avoid infinite change detection loops. And comparisons happen at a local level only for the current change and its children, not for the whole app. The Angular team optimized all of this to take full advantage of the JavaScript engines inside modern browsers. Angular's default change detection strategy always checks for changes unless you explicitly deactivate it inside a component. Depending on your use case, you may want to have Angular check the component only once, and then wait until you trigger a change. This strategy is called OnPush, and it means Angular will check for changes when the component first loads, and then wait until you redefine a value or dispatch an event. The strategy you choose really depends on whether or not you're using immutable data in your project. You can use either strategy with immutable data but you must use Angular's default strategy if your data mutates. If you want full control of when and how your framework checks for changes, Angular might be a good choice for you. Reacts change detection works by storing a copy of the component DOM structure in memory. React calls this copy a Virtual DOM. It represents a moment in time for the application and all updates happen there before they're written out into the real DOM. Using a Virtual Dom is more efficient than changing the real DOM directly because the framework makes the browser re-render content only once when it writes the virtual DOM to the real Dom. In React, components trigger change detection whenever they call their render function. React then compares the old state with the new state. They call this process reconciliation, and it uses a custom algorithm to be as efficient as possible. Comparisons happen in one direction. From the render functions caller down into its children. Two elements are different, like changing a span into a div. React will rebuild a new tree for that element from scratch. If two elements are the same, React will compare the attributes on those elements, and update only the attributes with different values. These changes propagate down into all the child nodes of the component inside the Virtual DOM. Reconciliation continues until no more components call their render function. Only then will React write the new state to the real DOM. If you like the idea of managing state inside a Virtual DOM, React might be a good choice for your needs. Vue change detection works by tracking component properties inside a JavaScript proxy. Proxies are a native JavaScript feature that let you take an object, and redefine fundamental operations like getting and setting values. As of this recording, there are 13 different handlers you can use to change operations. These handlers are sometimes called traps. Vue uses traps inside the proxy to attach trackers and triggers to the properties defined on the component. When a component property changes, Vue updates the value, and reruns all the code that uses it. Vue calls this a reactive effect. Vue track's application stays inside a Virtual DOM similar to React. Vue will traverse the Virtual DOM. Run all the reactive effects needed. Reconcile changes between the old state, and the new state. And then write the new state to the real DOM. What makes Vue unique is that the framework includes both a compiler and a runtime. This means Vue can do static analysis of the code at and compile time, and leave hints for the comparison algorithm. This makes comparing app states more efficient than if Vue just did the comparison at runtime alone. If you like the idea of a Virtual DOM with compile time optimizations, Vue might be a good choice for you. But there are some things you need to keep in mind. Vue reactive effects only work on object types like arrays, objects and collections. They can't be primitive types like strings or numbers. This is because Vue uses a WeakMap under the hood to track properties, and the keys in a WeakMap must be an object type. You also can't change the reference to a reactive effect once it's set. And you'll break the change detection, if you assign a reactive property to a local variable. This is because of how proxies work, and how Vue tracks changes inside the WeakMap. These constraints are small, and there are official coding patterns to help you work within the limits of Vue's change detection system. Remember to check out the exercise files for links to more info. </p>

<p>
<h2>
 Dependency injection in Angular, React, and Vue</h2>
<br />
Dependency injection, DI for short, is a software design pattern where a class or function requests dependencies from an external source, rather than creating its own instances. You may want to use dependency injection or avoid it depending on your needs. Of the three frameworks we're talking about in this course Angular is the only one that requires dependency injection. If you want to avoid dependency injection, choose React or Vue instead, because you can't use Angular without DI. The upside to all this injection is flexibility. You can inject services into other services. You can inject services into the root of your project, or you can inject services into only one or two components. The choice is yours. It also makes testing and mocking services much easier, because you can proxy the dependencies. Let me break that down. Angular keeps a list of key value pairs that represent all the dependencies in your app. When you access a dependency using DI, Angular looks for that dependency in the list using the key. The key and its value are usually the same thing. I have a Hello World service. The key points to the Hello World service, but it doesn't need to. You could point the Hello World key at anything, including strings, an anonymous function, or even a mock of the service that returns the same value every time. This is why dependency injection makes testing so easy. You can write your component, inject the real service, and proxy to a mock of the service only in the test spec. Angular may be a good choice for you if you want complete control of when and how you inject dependencies. In React, there's no official dependency injection system. You'll need to manually inject services or make new instances inside the class. React does have something called a context, which lets you pass down global properties and services into deeply nested components, but React recommends component composition instead for most use cases. Component composition lets parent components render their children directly in the DOM without needing to know anything about the children's data. React may be a good choice for you if you want to use Vanilla JavaScript to inject dependencies. In VueJS, you can use the provide function to register dependencies and the inject function to use those dependencies somewhere else in the app. Dependency injection is not required to use the Vue framework, but it does make working with services and global data much easier. Like Angular, you register key value pairs with the framework to represent your dependencies and access those dependencies by key. VueJS does let you define default values when accessing dependencies, but there are no proxies. You'll need to proxy your own data. Vue may be a good choice for you if you want built in dependency injection but don't need proxies. Check out the exercise files for links to more info.</p>

<p>
<h2>
 Using decorators in your JavaScript app</h2><br />
Decorators are functions that return functions, it's that simple. But in Angular, they supply metadata about a particular class or property or value. They also help with dependency injection across the entire app. You mark code as a decorator by placing an @ symbol in front of the decorator name. They're invoked at runtime and expect arguments to be passed in either between the parentheses or immediately after the closing parentheses of the decorator. This is why semicolons are left off the end of the decorator expression and why parentheses, even empty ones, always follow the name of the decorator. There are many built-in decorators available in Angular. The ones I see most often are NG module, to define modules, component, to define components, injectable to define services and input and output, to define properties that are sent and received from the DOM. As of this recording, Angular requires the use of decorators and you'll use them in most of the files you write. If you like the idea of decorators, Angular might be a good choice for your needs. I think they make the source code clean and easy to work with. As of this recording, React doesn't use decorators in its core library. You use decorators only when you install a third party package that supports them. If you want to avoid decorators altogether React might be a good choice for you. You can use View with, or without decorators. View supports an optional library called View Class Component. This lets you write your components using JavaScript classes instead of functions or configuration objects. If you like the idea of optional decorators and class based components, View may be a good choice for your needs. Keep in mind that there's no native JavaScript support for decorators yet. So no matter which framework you choose you'll need to confirm that your project is set up correctly, to compile decorators into vanilla JavaScript code. Check out the exercise files for links to more info.
</p>

<p>
<h2> 
 App routing and deep links in Angular, React, and Vue
</h2><br />
Single-page applications have come a long way since they first appeared in 2003. Before SPAs, the only way to update a webpage was to send a request to the server and have the browser refresh the page. SPAs made it possible to change the content of the webpage without refreshing the browser. In turn, this made websites feel more like native desktop applications. People loved it, and the idea of web apps took hold. In those early days, developers didn't worry about app routing and deep links, there was nowhere for users to go. Everything a user needed to do happened on a single page, hence the name single-page application. Today, web apps are more complex than ever, spanning many pages and URLs. How your JavaScript framework manages routing and deep links can make all the difference in your end user's experience. Angular Router is the official package for managing routes in an Angular app. It's an optional package that you include as needed when you start a new project using the Angular CLI Tool. It comes with full support for lazy loading components, nested routes, route guards, redirects, URL, parameters, and everything else you'll need when navigating between pages in your app. By default, Angular Router uses the history API to manage navigation. All modern browsers support the history API and it lets Angular update the URL and browser history without triggering a page refresh. This navigation strategy is sometimes called HTML5 style URLs because browsers that support HTML5 also support the history API. Angular recommends using the HTML5 style URLs because they're easier for users to understand, are better for SEO, and they give you the option to do server-side rendering in the future. If you need support for older browsers, you should consider using hash style URLs instead. Older browsers always refresh the page when the URL changes, unless the change happens after a hash symbol. This is the very end of a URL and it's sometimes called a URL fragment. You can easily switch between the two styles by setting a bullion in your Angular Router configuration. React doesn't have an official package for routing. One popular option is called React Router released by a group called Remix. The package includes support for things like authentication, query parameters, and server-side rendering. It's a popular package with just under 8 million weekly downloads as of this recording. One thing to note, as of Version 6, React Router only supports HTML5 style URLs. There is no support for hash style URLs. You and your team will need to research all your options if you need support for hash style URLs in your React app. Vue Router is the official package for managing routes in a Vue.js application. It's an optional package that you include as needed when you start a new project using Vue's CLI Tool. Like other frameworks, it comes with the full support for route parameters, redirects, nested routes, wild cards and dynamic routes. It supports both HTML5 and hash style URLs, and you can easily switch between those styles using a configuration setting. Regardless of the framework you choose, you'll need to update your server to manage the deep links. By default, most servers will look for a static asset that matches the path of the URL. Since routing happens client-side in the browser, there's no assets for the server to send back and the user will see a 404 error instead. To avoid this, add a catch all route on your server that returns the index page if a URL doesn't match any static assets. App routing should work as expected once the browser receives the index page from the server. Remember to check out the exercise files for links to more info.</p>
<p>
<h2>
 Deploying your JavaScript app into the wild</h2><br />
Once you build your app, you'll need to deploy it into the wild. There are many ways to do this and Angular, React and Vue all take a slightly different approach. You may find that one framework is a better fit for your pipeline and your hosting service over the others. In Angular, there's two ways to deploy your apps, manual and automatic. You use Angular CLI tool for both techniques. Automatic deployments use targets defined in your workspace config to build and upload files to your hosting platform of choice. Angular automatically updates your workspace configuration when you add an Angular package to your project that has deployment capability. This makes it easy to build your code and deploy it to a platform like Firebase, Azure or Amazon S3 with one simple CLI command. Packages exist for other platforms like Vercel, Netlify, GitHub Pages and NPM. You can also write your own custom package if needed. The other option is to build your code using the Angular CLI tool, and then manually copy the static files over to your production server. You can always automate this step using a custom bash script or something similar. If you like the idea of automatic deployments using one command, Angular might be a good fit. React apps are just as easy to deploy. If you started your project using the Create React App tool, then your project's config file includes an NPM command to build your app's static files. All you need to do is copy the files to your hosting service and load the index.HTML page. Create React App builds files, assuming your app is hosted at the root of your server. You can always change the root path in your projects config if needed. If you like the idea of deploying static files to any server, React might be a good choice for you. Vue apps are also just a collection of static files. This means you can deploy them to any server, just like React, using the included NPM commands. Vue might also be a good option along with React if you like the idea of deploying static files to any server. Keep in mind that all three of these frameworks do a great job of chunking and hashing your build artifacts. This lets you take full advantage of lazy loaded assets and long term browser caching techniques. Your apps will be fast, no matter which framework you use. As always, be sure to check out the exercise files for links to more info.</p>
<p>
<h2>
 Other JavaScript frameworks beyond Angular, React, and Vue</h2><br />
Angular, React, and Vue are popular choices for a frontend JavaScript framework but there are other frameworks out there that may work better for your needs. Backbone and Knockout first appeared in 2010. Backbone is a lightweight framework with only one required dependency. It's a great framework for single-page applications. Knockout is also a lightweight framework but with no external dependencies. It still supports very old web browsers like Internet Explorer 6 and Firefox 3.5. This is a great choice if you need support for those ancient platforms. Ember came onto the scene in 2011. It's an all-in-one solution that prioritizes conventions over configuration, very similar to the philosophy used by Ruby on Rails. This might be a good choice if you like the idea of having one right way of doing things. Another great option is jQuery. The first release of jQuery was back in 2006. And while it's not a true framework like Angular or Backbone, it's been around for as long as I can remember. What it does it does well, DOM manipulation, event handling, CSS animations, and ajax requests. It's very likely that some of the websites you use every day still use jQuery. This is a great choice if your project is more like a traditional website and less like a full-scale web app. There are some newer frameworks you should also know about. Preact spelled with a P as in papa is a lightweight alternative to React with most of the same API. There's also Svelte and SvelteKit. Svelte is a front-end compiler that uses a file structure similar to Vue.js. The difference is that Svelte works at build time, not runtime, to generate DOM-friendly code that loads super fast. SvelteKit is a full framework built on top of the Svelte compiler. SvelteKit is still in early stage development as of this recording. The Stencil compiler is another option. Like Svelte, it works at build time and generates standard web components you can use anywhere. I'm a big fan of Stencil and think their API is very easy to use. There's also a super new framework called Qwik, spelled Q-W-I-K. Qwik is an HTML-first framework that lazy-loads as much JavaScript as possible. This is very different from traditional frameworks that load all the JavaScript up front. Apps that use Qwik have a much shorter time to interactive than apps that use other frameworks. Qwik might be a good choice if you like the idea of lazy-loading JavaScript, but keep in mind that as of this recording, Qwik is very new and the API is subject to change. If you need to build mobile apps for iOS and Android or desktop apps for Windows, Mac, and Linux, you can use the Ionic Framework, React Native, Svelte Native, and Electron. These frameworks come with special APIs for interacting with things like the clipboard, location services, and the device camera. I strongly recommend looking into these specialized frameworks if you need to build a mobile app or desktop app. All of these projects are open-source and released under the MIT license. And remember, check out the exercise files for links to more info.

</p>
 
